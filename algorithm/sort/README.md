# Sort

## 概念

- 排序算法的执行效率
  - 最好、最坏、平均情况时间复杂度
  - 时间复杂度的系数、常数、低阶（因为实际问题除了大数据，一般都是规模较小的）
  - 比较次数和交换次数
- 内存的消耗
  - 原地排序（sorted in place），空间复杂度是O(1)的排序算法
- 稳定性
  - 稳定的排序算法：相同的两个数，在经过排序后，相对位置没有发生变化；
  - 不稳定的：相对位置发生了变化
  - 实际应用，往往不像练习时都是一个数组排序，比如对一个表格的两列进行同时排序，价格从小到达，相同价格内部时间从早到晚，类似这种问题就可以借助稳定排序

## 冒泡排序

Bubble Sort

- 原地排序算法
- 时间复杂度：最坏O(n^2)，最好1次遍历 O(n)
- 稳定排序
- 优化：提供一个flag，如果某次没有发生交换，则可以终止
  - 经过测试，在可接受的执行时间内，优化不明显
- 利用`有序度`的概念分析时间复杂度

## 插入排序

insertion sort

- 思考题：为什么同样的复杂度，插入更受欢迎？
  - 冒泡的交换操作更复杂，一次冒泡的交换次数更多
  - 插入排序中，提前拿到了要插入的值，只需将大的元素整体后移一个位置，然后插入该元素即可

- 原地排序算法
- 时间复杂度：O(n^2)
  - 在数组中插入一个元素的复杂度是O(n)，重复执行n次
- 可以是稳定排序算法：将后面出现的值，插入到前面出现元素的后面，保持有序，如果不这样处理，则算法会变为不稳定

### 希尔排序（递减增量排序算法）

插入排序的改进版

- 非稳定
- 时间复杂度O(n^(1.3~2))，好于n^2但是差于nlogn的算法

## 选择排序

Selection Sort

和插入排序思路类似，不过插入是将下一个元素放到有序区间中，选择是每次将无序区间最小的元素放入有序区间的末尾（与无序区间第一个元素交换位置）

- 原地排序
- 不稳定算法，因为交换位置的时候，破坏了稳定性
- 最坏情况和平均情况都是O(n^2)

## 归并排序 Merge Sort

- 空间复杂度：O(n)
- 时间复杂度： O(nlogn)
- 稳定算法，merge的时候保持相同元素的顺序即可
- 分治思想

## 快速排序 QuickSort

- 空间复杂度：O(1)，通过优化分区操作可以达到
- 时间复杂度： O(nlogn)
- 不稳定算法
- 分治

## 课后思考

- 大文件，外部排序

现在你有 10 个接口访问日志文件，每个300MB，有序，合并为1个新的有序的文件，内存限定1GB？
  > 桶排序

## 线性排序

### 桶排序 Bucket Sort

将数据分到有序的桶里面，然后每个桶再单独排序，桶内排序完之后，再把每个桶里的数据按照顺序组成序列就是有序的了。

- 时间复杂度，O(n)，当桶数量接近数据个数n时，反之会退化为O(nlogn)
- 适用于外部排序

### 计数排序

计数排序时桶排序的一种特殊情况，比如最大值是k，则分为k个桶，省掉了桶内排序的时间。

只能应用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序了。而且，只能给非负整数排序，如果要排序的数据是其他类型，在不改变其相对大小的情况下，要转化为非负整数。

### 基数排序 Radix sort

- 时间复杂度O(n)
- 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系。同时，每一位的数据范围不能太大，要可以用线性排序的算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。

## 排序优化

如何实现一个通用的、高性能的排序函数？

### 如何优化快排

退化原因：每次分区点都在最后一个数据，这样会变得非常糟糕。

优化思路：最理想的分区点，分开的两个分区中，数据的数量差不多。

- 三数取中法
  - 首、尾、中取3个数，中间的值作为分区点，如果数组比较大，可以考虑五数取中或十数取中
- 随机法，随机选一个数

## 举例分析排序函数

一些函数提供的排序，不仅仅使用一种排序算法，会根据数据量来综合调整。

考虑数据量（低阶、系数、常数）等时，O(n^2)不一定比O(nlogn)要差。

python中的list.sort默认实现是[Timsort](http://en.wikipedia.org/wiki/Timsort)，该算法找到数据中已经排好序的块-分区，每一个分区叫一个run，可以保证稳定性。[参考](https://www.cnblogs.com/clement-jiao/p/9243066.html)

来自课后评论，TimSort算法, 大致思路是这样的：

- 元素个数 < 32, 采用二分查找插入排序(Binary Sort)
- 元素个数 >= 32, 采用归并排序，归并的核心是分区(Run)
- 找连续升或降的序列作为分区，分区最终被调整为升序后压入栈
- 如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阙值
- 每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并
- 最终栈内的分区被全部合并，得到一个排序好的数组

Timsort的合并算法非常巧妙：

- 找出左分区最后一个元素(最大)及在右分区的位置
- 找出右分区第一个元素(最小)及在左分区的位置
- 仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的
