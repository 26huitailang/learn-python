# Sort

## 概念

- 排序算法的执行效率
  - 最好、最坏、平均情况时间复杂度
  - 时间复杂度的系数、常数、低阶（因为实际问题除了大数据，一般都是规模较小的）
  - 比较次数和交换次数
- 内存的消耗
  - 原地排序（sorted in place），空间复杂度是O(1)的排序算法
- 稳定性
  - 稳定的排序算法：相同的两个数，在经过排序后，相对位置没有发生变化；
  - 不稳定的：相对位置发生了变化
  - 实际应用，往往不像练习时都是一个数组排序，比如对一个表格的两列进行同时排序，价格从小到达，相同价格内部时间从早到晚，类似这种问题就可以借助稳定排序

## 冒泡排序

Bubble Sort

- 原地排序算法
- 时间复杂度：最坏O(n^2)，最好1次遍历 O(n)
- 稳定排序
- 优化：提供一个flag，如果某次没有发生交换，则可以终止
  - 经过测试，在可接受的执行时间内，优化不明显
- 利用`有序度`的概念分析时间复杂度

## 插入排序

insertion sort

- 思考题：为什么同样的复杂度，插入更受欢迎？
  - 冒泡的交换操作更复杂，一次冒泡的交换次数更多
  - 插入排序中，提前拿到了要插入的值，只需将大的元素整体后移一个位置，然后插入该元素即可

- 原地排序算法
- 时间复杂度：O(n^2)
  - 在数组中插入一个元素的复杂度是O(n)，重复执行n次
- 可以是稳定排序算法：将后面出现的值，插入到前面出现元素的后面，保持有序，如果不这样处理，则算法会变为不稳定

### 希尔排序（递减增量排序算法）

插入排序的改进版

- 非稳定
- 时间复杂度O(n^(1.3~2))，好于n^2但是差于nlogn的算法

## 选择排序

Selection Sort

和插入排序思路类似，不过插入是将下一个元素放到有序区间中，选择是每次将无序区间最小的元素放入有序区间的末尾（与无序区间第一个元素交换位置）

- 原地排序
- 不稳定算法，因为交换位置的时候，破坏了稳定性
- 最坏情况和平均情况都是O(n^2)
