# 算法图解

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 链接

- [grokking_algorithms](https://github.com/egonschiele/grokking_algorithms)

## 第一章 算法简介

### 二分查找

二分查找是一种算法，其输入是一个有序的元素列表`(必须有序的原因稍后解释)`。如果要 查找的元素包含在列表中，二分查找返回其位置;否则返回null。

时间复杂度：

$$ T(n) = O(\log_2n) = O(\log_n) $$

### 大O表示法

指出算法最糟糕情况下的运行时间。除此之外，还可能会考虑`平均情况`。

### 旅行商问题

是一个`n!`阶乘复杂度的问题

### 小结

- 二分查找的速度比简单查找快得多。
- O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
- 算法运行时间并不以秒为单位。
- 算法运行时间是从其增速的角度度量的。
- 算法运行时间用大O表示法表示。

## 第二章 选择排序

两种基本数据结构：数组、链表

### 内存

数组、链表存放在内存的方式不同：

- `数组`是连续的内存空间，如果要添加和删除元素可能都会重新分配内存。可以通过预留的方式提前申请冗余的内存空间以防止重新分配，但是可能造成浪费，超过预留空间还是要重新分配。
- `链表`，可以存放在内存任何地方，每个元素都有下一个元素的地址，链表优势在插入元素方面，理论上修改前一个元素的next和插入元素即可。
  - 劣势，如果要读取后面的元素，不能跳跃，必须从第一个开始逐个获取

### 访问方式

随机访问（数组）和顺序访问（链表）。

数组和链表被用来实现其他数据结构。

### 选择排序

$$ T(n) = O(n^2) $$

## 第三章 递归

使用循环，程序的性能可能更高；使用递归，可能更容易理解。

### 基线条件和递归条件

- base case，函数不再调用自己，避免形成无限循环
- recursive case，函数调用自己

### 栈

- 调用栈
- 递归是如何使用调用栈的，每一层递归函数都有自己的变量
- 递归每层调用都需要内存存储详尽的信息，会有大量占用
  - 栈太高的话，改写为循环
  - 或者使用尾递归，高级递归主题，另查阅
- 栈溢出

## 第四章 快速排序

### 分而治之（分治法）

重要思想，分而治之 `divide and conquer, D&C`。

DC工作原理：

1. 找出简单的基线条件；
2. 确定如何缩小问题的规模，使其符合基线条件

习题：

4-1

```python
def cal_sum(arr):
    if not arr:
        return 0
    return arr[0] + cal_sum(arr[1:])
```

4-2

```python
def count(arr):
    if not arr:
        return 0
    return 1 + count(arr[1:])
```

4-3

```python
def get_arr_max(arr):
    if len(arr) == 2:  # 基线条件，当长度为2时，返回一个较大值
        return arr[0] if arr[0] > arr[1] else arr[1]
    sub_max = get_arr_max(arr[1:])  # 递归，arr[0]和分解后结果比较
    return arr[0] if arr[0] > sub_max else sub_max
```

4-4，二分的基线条件，low和high之间没有元素时，二分后符合条件的部分继续递归。

### 快速排序

快速排序使用了DC原理。

利用一个基准值，分成两部分，递归，直到数组长度为1

[A list], 基准值, [B list]

快速排序的平均运行时间 $$ O(nlogn) $$，最坏的是每次结果都和选择排序一样，为$$ O(n^2) $$。 

### 合并排序（归并排序）和快速排序

常量的影响在数量级小的时候有很大影响，但是如果在比较大的时候，类似二分查找还是比简单查找快很多的，即使常量中一次运行的时间是1秒和10毫秒，不足以抵消在算法在大O复杂度下的影响。

#### 平均情况，最糟情况

快速排序的性能高度依赖于选择的基准值，最糟糕的情况就是每次选中的基准值都是最大（小）的那一个。

快速排序的复杂度是调用栈高度 * 每层需要的时间( $$ O(logn) * O(n) = O(nlogn) $$ )，前面说的最糟糕的情况就是调用栈达到数组长度n，$$ O(n) * O(n) = O(n^2) $$ 。 

一般情况下，最佳情况也是平均情况，对于快排，每次都是随机选择一个基准值，快排的平均时间就是$$ O(nlogn) $$。

快速排序是最快的排序算法之一，也是分治法的典范。归并也是分治法。

### 练习

4-5 $$ O(n) $$

4-6  $$ O(n) $$

4-7 $$ O(1) $$

4-8 $$ O(n^2) $$

## 第五章 散列表

最有用的基本数据结构之一。hash table

理解散列表的内部机制：实现、冲突和散列函数，有帮助于理解如何分析散列表的性能。

商店查价格的例子，即使使用有序数组和二分查找，时间还是O(logn)。如果想要做到O(1)，那么就需要散列函数。

### 散列函数

散列函数：无论你给它什么数据，它都还你一个数字。

要求：

- 一致性，保证每次输入apple时，得到的结果是一致的，否则，散列表毫无意义
- 不同输入映射到不同的数字，如果一个结果对应可以有两个映射，那么不是一个好的散列函数。

散列表也使用数组来存储数据，这里猜测应该是将key散列后的值也value的对应关系。

python提供的dict就是散列表功能。

### 缓存

比如网页的缓存，将url映射到页面数据，这就是一个散列表，不用重复计算。

```python
cache = dict()

def get_page(url):
    if url in cache:
        return cache[url]
    else:
        data = get_data_from_server(url)
        cache[url] = data
        return data
```

散列表适用于：

- 模拟映射关系
- 防止重复
- 缓存/记住数据，以免服务器再通过计算来生成它们

### 冲突



