# 算法图解

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 链接

- [grokking_algorithms](https://github.com/egonschiele/grokking_algorithms)

## 第一章 算法简介

### 二分查找

二分查找是一种算法，其输入是一个有序的元素列表`(必须有序的原因稍后解释)`。如果要 查找的元素包含在列表中，二分查找返回其位置;否则返回null。

时间复杂度：

$$ T(n) = O(\log_2n) = O(\log_n) $$

### 大O表示法

指出算法最糟糕情况下的运行时间。除此之外，还可能会考虑`平均情况`。

### 旅行商问题

是一个`n!`阶乘复杂度的问题

### 小结

- 二分查找的速度比简单查找快得多。
- O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
- 算法运行时间并不以秒为单位。
- 算法运行时间是从其增速的角度度量的。
- 算法运行时间用大O表示法表示。

## 第二章 选择排序

两种基本数据结构：数组、链表

### 内存

数组、链表存放在内存的方式不同：

- `数组`是连续的内存空间，如果要添加和删除元素可能都会重新分配内存。可以通过预留的方式提前申请冗余的内存空间以防止重新分配，但是可能造成浪费，超过预留空间还是要重新分配。
- `链表`，可以存放在内存任何地方，每个元素都有下一个元素的地址，链表优势在插入元素方面，理论上修改前一个元素的next和插入元素即可。
  - 劣势，如果要读取后面的元素，不能跳跃，必须从第一个开始逐个获取

### 访问方式

随机访问（数组）和顺序访问（链表）。

数组和链表被用来实现其他数据结构。

### 选择排序

$$ T(n) = O(n^2) $$

## 第三章 递归

使用循环，程序的性能可能更高；使用递归，可能更容易理解。

### 基线条件和递归条件

- base case，函数不再调用自己，避免形成无限循环
- recursive case，函数调用自己

### 栈

- 调用栈
- 递归是如何使用调用栈的，每一层递归函数都有自己的变量
- 递归每层调用都需要内存存储详尽的信息，会有大量占用
  - 栈太高的话，改写为循环
  - 或者使用尾递归，高级递归主题，另查阅
- 栈溢出

## 第四章 快速排序

### 分而治之

重要思想，分而治之 `divide and conquer, D&C`。

DC工作原理：

1. 找出简单的基线条件；
2. 确定如何缩小问题的规模，使其符合基线条件

习题：

4-1

```python
def cal_sum(arr):
    if not arr:
        return 0
    return arr[0] + cal_sum(arr[1:])
```

4-2

```python
def count(arr):
    if not arr:
        return 0
    return 1 + count(arr[1:])
```

4-3

```python
def get_arr_max(arr):
    if len(arr) == 2:  # 基线条件，当长度为2时，返回一个较大值
        return arr[0] if arr[0] > arr[1] else arr[1]
    sub_max = get_arr_max(arr[1:])  # 递归，arr[0]和分解后结果比较
    return arr[0] if arr[0] > sub_max else sub_max
```

4-4，二分的基线条件，low和high之间没有元素时，二分后符合条件的部分继续递归。

### 快速排序

快速排序使用了DC原理。

利用一个基准值，分成两部分，递归，直到数组长度为1

[A list], 基准值, [B list]

快速排序的平均运行时间 $$ O(nlogn) $$，最坏的是每次结果都和选择排序一样，为$$ O(n^2) $$。 

### 合并排序和快速排序

